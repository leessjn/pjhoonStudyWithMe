<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Study Time Tracker</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; max-width: 800px; margin: 0 auto; }
        #videoInput, #canvasOutput { max-width: 100%; display: block; margin: 10px auto; }
        button { margin: 10px; padding: 10px; }
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Study Time Tracker</h1>
    
    <div id="status" class="error"></div>
    
    <div id="timer">00:00:00</div>
    <div id="total-time">Total Study Time: 00:00:00</div>
    
    <video id="videoInput" width="640" height="480" autoplay playsinline></video>
    <canvas id="canvasOutput"></canvas>

    <div>
        <input type="text" id="username" placeholder="Enter your username">
        <button id="startBtn" disabled>Start Studying</button>
        <button id="stopBtn" disabled>Stop Studying</button>
    </div>

    <div id="rankings">
        <h2>Study Time Rankings</h2>
        <table>
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Username</th>
                    <th>Total Study Time</th>
                </tr>
            </thead>
            <tbody id="rankingsBody"></tbody>
        </table>
    </div>

    <script src="https://docs.opencv.org/4.5.2/opencv.js"></script>
    <script>
        // Global variables
        let videoInput, canvasOutput, videoCapture;
        let studyTimer;
        let totalSeconds = 0;
        let sessionSeconds = 0;
        let isStudying = false;
        let isDistracted = false;
        let distractionStartTime = 0;

        function showStatus(message, isError = true) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.style.display = message ? 'block' : 'none';
            statusEl.style.color = isError ? 'red' : 'green';
        }

        // Ranking functions (same as before)
        function loadRankings() {
            const rankings = JSON.parse(localStorage.getItem('studyRankings') || '[]');
            rankings.sort((a, b) => b.total_study_time - a.total_study_time);
            return rankings;
        }

        function saveRankings(rankings) {
            localStorage.setItem('studyRankings', JSON.stringify(rankings));
            displayRankings(rankings);
        }

        function displayRankings(rankings) {
            const rankingsBody = document.getElementById('rankingsBody');
            rankingsBody.innerHTML = rankings.map((rank, index) => `
                <tr>
                    <td>${index + 1}</td>
                    <td>${rank.name}</td>
                    <td>${formatTime(rank.total_study_time)}</td>
                </tr>
            `).join('');
        }

        function formatTime(totalSecs) {
            const hours = Math.floor(totalSecs / 3600);
            const minutes = Math.floor((totalSecs % 3600) / 60);
            const seconds = totalSecs % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            document.getElementById('timer').textContent = formatTime(sessionSeconds);
            document.getElementById('total-time').textContent = `Total Study Time: ${formatTime(totalSeconds)}`;
        }

        function detectDistraction(src) {
            try {
                let gray = new cv.Mat();
                let binary = new cv.Mat();
                
                // Convert to grayscale
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // Binary thresholding
                cv.threshold(gray, binary, 50, 255, cv.THRESH_BINARY_INV);
                
                // Find contours
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                for (let i = 0; i < contours.size(); i++) {
                    let contour = contours.get(i);
                    let rect = cv.boundingRect(contour);
                    
                    // Aspect ratio and area checks 
                    let aspectRatio = rect.width / rect.height;
                    let area = cv.contourArea(contour);
                    
                    if (aspectRatio >= 0.4 && aspectRatio <= 2.5 && 
                        area > 5000 && area < 100000) {
                        
                        // Draw red rectangle for distraction
                        cv.rectangle(src, 
                            new cv.Point(rect.x, rect.y), 
                            new cv.Point(rect.x + rect.width, rect.y + rect.height), 
                            [0, 0, 255, 255], 2
                        );
                        
                        // Free memory
                        gray.delete(); binary.delete(); 
                        contours.delete(); hierarchy.delete();
                        
                        return true;
                    }
                }
                
                // Free memory
                gray.delete(); binary.delete(); 
                contours.delete(); hierarchy.delete();
            } catch (error) {
                console.error("Distraction detection error:", error);
            }
            
            return false;
        }

        function processVideo() {
            if (!isStudying || !window.cv) return;

            try {
                let src = new cv.Mat(videoInput.height, videoInput.width, cv.CV_8UC4);
                let dst = new cv.Mat(videoInput.height, videoInput.width, cv.CV_8UC4);
                
                videoCapture.read(src);
                src.copyTo(dst);

                let detectedDistraction = detectDistraction(dst);
                
                if (detectedDistraction) {
                    if (!isDistracted) {
                        isDistracted = true;
                        distractionStartTime = Date.now();
                    }
                    
                    // More than 5 seconds of distraction
                    if (Date.now() - distractionStartTime > 5000) {
                        isStudying = false;
                        showStatus("Distraction detected. Study paused.", false);
                    }
                } else {
                    isDistracted = false;
                    sessionSeconds++;
                    totalSeconds++;
                }

                // Draw canvas
                cv.imshow('canvasOutput', dst);
                
                // Update display
                updateTimerDisplay();
                
                // Free memory
                src.delete(); dst.delete();
            } catch (error) {
                console.error("Video processing error:", error);
                showStatus("Error processing video. Please restart.");
            }
        }

        function startStudy() {
            const username = document.getElementById('username').value || 'Anonymous';
            if (!username) {
                showStatus("Please enter a username");
                return;
            }

            isStudying = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            studyTimer = setInterval(processVideo, 1000);
        }

        function stopStudy() {
            clearInterval(studyTimer);
            
            const username = document.getElementById('username').value || 'Anonymous';
            const rankings = loadRankings();
            
            const userRankIndex = rankings.findIndex(r => r.name === username);
            if (userRankIndex !== -1) {
                rankings[userRankIndex].total_study_time += totalSeconds;
            } else {
                rankings.push({ name: username, total_study_time: totalSeconds });
            }
            
            rankings.sort((a, b) => b.total_study_time - a.total_study_time);
            saveRankings(rankings);
            
            // Reset
            isStudying = false;
            sessionSeconds = 0;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateTimerDisplay();
        }

        function initializeOpenCV() {
            try {
                // Wait for OpenCV to be fully loaded
                if (!window.cv) {
                    showStatus("Waiting for OpenCV to load...");
                    setTimeout(initializeOpenCV, 100);
                    return;
                }

                videoInput = document.getElementById('videoInput');
                canvasOutput = document.getElementById('canvasOutput');
                
                // Setup video capture
                videoCapture = new cv.VideoCapture(videoInput);
                
                document.getElementById('startBtn').onclick = startStudy;
                document.getElementById('stopBtn').onclick = stopStudy;
                
                // Enable start button
                document.getElementById('startBtn').disabled = false;
                
                // Load existing rankings
                displayRankings(loadRankings());
                
                showStatus("Ready to start studying!", false);
            } catch (error) {
                console.error("OpenCV initialization error:", error);
                showStatus("Failed to initialize. Refresh the page.");
            }
        }

        function initializeWebcam() {
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 640 }, 
                    height: { ideal: 480 } 
                } 
            })
            .then(stream => {
                const videoInput = document.getElementById('videoInput');
                videoInput.srcObject = stream;
                videoInput.onloadedmetadata = () => {
                    videoInput.play();
                    
                    // Check if OpenCV is already loaded
                    if (window.cv) {
                        initializeOpenCV();
                    } else {
                        // If not, wait a bit and then try initialization
                        document.addEventListener('opencv_loaded', initializeOpenCV);
                    }
                };
            })
            .catch(err => {
                console.error("Webcam access error", err);
                showStatus("Webcam access denied. Please allow camera access.");
            });
        }

        // Trigger initialization when page loads
        document.addEventListener('DOMContentLoaded', initializeWebcam);

        // Fallback OpenCV loading check
        setTimeout(() => {
            if (!window.cv) {
                showStatus("OpenCV failed to load. Check your internet connection.");
            }
        }, 5000);
    </script>
</body>
</html>
